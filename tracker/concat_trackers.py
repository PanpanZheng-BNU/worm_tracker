from tracker.iou import *


def df_iou(last_bbox, df):
    """
    df_iou: Calculating the IoU between one bboxes and all bboxes in a frame. And return the bboxes with IOU > 0.
    Args:
        last_bbox: a bbox
        df: a frame dataframe from all_dfs
    """
    return df[([iou(last_bbox, i) > 0 for i in np.array(df[["x", "y", "w", "h"]])])]


def find_initial(long_dfs, num, trackers_summarize):
    """
    find_initial: Identify initial trackers to concatenate.
    Args:
        `long_dfs`: a dataframe containing all detection results for each frame.
        `num`: int, the number of worms on the plate (or initial trackers).
        `trackers_summarize`: the summarize dataframe generated by `generate_summarize`
    Returns:
        `df`: a summarize dataframe for all initial trackers.
    """
    counts_df = long_dfs.groupby(
        "frame"
    ).size()  # counts the number of dets at each frame
    counts_df.index = counts_df.index.astype(int)
    counts_df.columns = ["counts"]

    indx_target = counts_df[counts_df >= num].index
    threshold = 1
    indx_split = np.split(
        indx_target, np.where(np.diff(indx_target) > threshold)[0] + 1
    )
    arg_max_split = np.argmax([len(i) for i in indx_split])
    frame_min, frame_max = indx_split[arg_max_split][0], indx_split[arg_max_split][-1]
    tmp_df = trackers_summarize.loc[
        (trackers_summarize["start_frame"] <= frame_min)
        & (trackers_summarize["end_frame"] >= frame_max)
    ]

    return tmp_df


def generate_summarize(all_trackers):
    """
    generate_summarize: Generates a summary dataframe for trackers.
    Args:
        `all_trackers`: dict of trackers
    Returns:
        tmp_df: The dataframe columns include: tracker ID, start frame, end frame, duration, start bbox, end bbox, start centroid, and end centroid.
    """
    tmp_df = pd.DataFrame(
        columns=[
            "tracker_id",
            "start_frame",
            "end_frame",
            "duration",
            "start_bbox",
            "end_bbox",
            "start_centroid",
            "end_centroid",
        ]
    )
    for i in all_trackers:
        tmp_tracker_id = int(i)
        tmp_tracker = all_trackers[i]
        tmp_start_frame = tmp_tracker["start_frame"]
        tmp_end_frame = tmp_tracker["end_frame"]
        tmp_durations = tmp_end_frame - tmp_start_frame
        tmp_start_bbox = tmp_tracker["bboxes"][0]
        tmp_end_bbox = tmp_tracker["bboxes"][-1]
        tmp_start_centroids = tmp_tracker["centroids"][0]
        tmp_end_centroids = tmp_tracker["centroids"][-1]
        tmp_df.loc[len(tmp_df)] = [
            tmp_tracker_id,
            tmp_start_frame,
            tmp_end_frame,
            tmp_durations,
            tmp_start_bbox,
            tmp_end_bbox,
            tmp_start_centroids,
            tmp_end_centroids,
        ]
    return tmp_df


def find_bbox(all_trackers, bbox_df):
    tmp_indx = []
    tmp_frame = []
    for j in range(len(bbox_df)):
        bbox = bbox_df.iloc[j][["x", "y", "w", "h"]].values
        for i in all_trackers:
            indx = np.where(
                np.all(np.array(all_trackers[i]["bboxes"]) == bbox, axis=1)
            )[0]
            for k in indx:
                if (k + all_trackers[i]["start_frame"]) in bbox_df.index:
                    tmp_indx.append(int(i))
                    tmp_frame.append(bbox_df.index.values[0])
    return tmp_indx, tmp_frame


def right_find(tmp_df, long_dfs):
    """
    Args:
        trackers_summarize: dataframe summarizing all trackers, consists of tracker_id, start_frame, end_frame, duration, start_bbox, end_bbox, start_centroid, end_centroid
        long_dfs: the information of each frame in a video
    Returns:
    """

    tmp_end_bbox = tmp_df.end_bbox
    tmp_end_frame = tmp_df.end_frame

    return df_iou(tmp_end_bbox, long_dfs.loc[[tmp_end_frame + 1]])


def left_find(tmp_df, long_dfs):
    """
    Args:
        trackers_summarize: dataframe summarizing all trackers, consists of tracker_id, start_frame, end_frame, duration, start_bbox, end_bbox, start_centroid, end_centroid
        long_dfs: the information of each frame in a video
    Returns:
    """

    tmp_start_bbox = tmp_df.start_bbox
    tmp_start_frame = tmp_df.start_frame

    return df_iou(tmp_start_bbox, long_dfs.loc[[tmp_start_frame - 1]])


def edge_type(tmp_df, long_dfs, all_trackers):
    """
    Args:
        trackers_summarize: dataframe summarizing all trackers, consists of tracker_id, start_frame, end_frame, duration, start_bbox, end_bbox, start_centroid, end_centroid
        long_dfs: the information of each frame in a video
    Returns:
    """

    if tmp_df.start_frame - 1 not in long_dfs.index:
        left_prev = ([], [])
    else:
        left_find_df = left_find(tmp_df, long_dfs)
        left_prev = find_bbox(all_trackers, left_find_df)

    if tmp_df.end_frame + 1 not in long_dfs.index:
        right_next = ([], [])
    else:
        right_find_df = right_find(tmp_df, long_dfs)
        right_next = find_bbox(all_trackers, right_find_df)

    if len(right_next[0]) == 0:
        tmp_right_type = "disappear"
    elif len(right_next[0]) == 1:
        tmp_right_type = "merge"
    elif len(right_next[0]) > 1:
        tmp_right_type = "split"

    if len(left_prev[0]) == 0:
        tmp_left_type = "appear"
    elif len(left_prev[0]) == 1:
        tmp_left_type = "split"
    elif len(left_prev[0]) > 1:
        tmp_left_type = "merge"

    return tmp_left_type, tmp_right_type, left_prev, right_next


# tmp methods for conn_disappear
def conn_disappear_next(tmp_df, merge_trackers_summarize):
    tmp_end_frame = tmp_df.end_frame
    tmp_end_centroids = tmp_df.end_centroid
    tmp_end_bbox = tmp_df.end_bbox

    indx_frame = (
        (merge_trackers_summarize.start_frame > tmp_end_frame)
        & ((merge_trackers_summarize.start_frame - tmp_end_frame) <= 100)
        & (merge_trackers_summarize.left_type == "appear")
    )

    tmp_next_df = merge_trackers_summarize.loc[indx_frame]
    # print(tmp_next_df)
    if len(tmp_next_df) == 0:
        return "can't find"
    else:
        distance_series = pd.Series(
            {
                i: np.linalg.norm(
                    np.array(tmp_next_df.loc[i].start_centroid)
                    - np.array(tmp_end_centroids)
                )
                for i in tmp_next_df.index
            },
            name="distance",
        )
        diff_frames_series = pd.Series(
            {
                i: np.abs(tmp_next_df.loc[i].start_frame - tmp_end_frame)
                for i in tmp_next_df.index
            },
            name="diff_frames",
        )
        overlapping_series = pd.Series(
            {
                i: iou(tmp_next_df.loc[i].start_bbox, tmp_end_bbox) > 0
                for i in tmp_next_df.index
            },
            name="is_overlapping",
        )
        tmp_df = pd.concat(
            [tmp_next_df, overlapping_series, diff_frames_series, distance_series],
            axis=1,
        )
        tmp_df = tmp_df.loc[tmp_df.distance / tmp_df.diff_frames < 5]
        if len(tmp_df) == 0:
            return "can't find"
        tmp_df.sort_values(by=["distance", "diff_frames"], inplace=True)
        return tmp_df.iloc[0].tracker_id


def conn_disappear_prev(tmp_df, merge_trackers_summarize):
    tmp_start_frame = tmp_df.start_frame
    tmp_start_centroids = tmp_df.start_centroid
    tmp_start_bbox = tmp_df.start_bbox

    indx_frame = (
        (merge_trackers_summarize.end_frame < tmp_start_frame)
        & (np.abs(merge_trackers_summarize.end_frame - tmp_start_frame) <= 100)
        & (merge_trackers_summarize.right_type == "disappear")
    )

    tmp_prev_df = merge_trackers_summarize.loc[indx_frame]
    tmp_indx = tmp_prev_df.index.to_numpy()
    # print(tmp_prev_df)
    if len(tmp_prev_df) == 0:
        return "can't find"
    else:
        distance_series = pd.Series(
            {
                i: np.linalg.norm(
                    np.array(tmp_prev_df.loc[i].end_centroid)
                    - np.array(tmp_start_centroids)
                )
                for i in tmp_indx
            },
            name="distance",
        )
        diff_frames_series = pd.Series(
            {
                i: np.abs(tmp_prev_df.loc[i].end_frame - tmp_start_frame)
                for i in tmp_indx
            },
            name="diff_frames",
        )
        overlapping_series = pd.Series(
            {i: iou(tmp_prev_df.loc[i].end_bbox, tmp_start_bbox) > 0 for i in tmp_indx},
            name="is_overlapping",
        )
        mean_velocity_series = pd.Series(
            {
                i: np.linalg.norm(
                    np.array(tmp_prev_df.loc[i].end_centroid)
                    - np.array(tmp_start_centroids)
                )
                / np.abs(tmp_prev_df.loc[i].end_frame - tmp_start_frame)
                < 5
                for i in tmp_indx
            },
            name="mean_velocity",
        )
        tmp_df = pd.concat(
            [
                tmp_prev_df,
                overlapping_series,
                diff_frames_series,
                mean_velocity_series,
                distance_series,
            ],
            axis=1,
        )
        tmp_df = tmp_df.loc[tmp_df.distance / tmp_df.diff_frames < 5]
        if len(tmp_df) == 0:
            return "can't find"
        tmp_df.sort_values(by=["distance", "diff_frames"], inplace=True)
        return tmp_df.iloc[0].tracker_id


def split_from(tracker_id, merge_trackers_summarize):
    tmp_df = merge_trackers_summarize
    tmp_df_1 = tmp_df.loc[[tracker_id in j[0] for j in tmp_df.left_prev]]

    this_end = tmp_df.loc[tmp_df.tracker_id == tracker_id].end_frame.values
    this_start = tmp_df.loc[tmp_df.tracker_id == tracker_id].start_frame.values

    result_df = pd.DataFrame(
        columns=["this_id", "nex_id", "this_start", "this_end", "nex_start", "nex_end"]
    )
    result_df.loc[len(result_df)] = [
        tracker_id,
        tmp_df_1.tracker_id.values,
        this_start,
        this_end,
        tmp_df_1.start_frame.values,
        tmp_df_1.end_frame.values,
    ]
    result_df["difference"] = np.abs(result_df.nex_start - result_df.this_end) - 1
    result_df["is_split"] = np.any(result_df["difference"].values[0])

    return result_df


def merge_to(tracker_id, merge_new_summarize):
    tmp_df = merge_new_summarize
    tmp_df_1 = tmp_df.loc[[tracker_id in j[0] for j in tmp_df.right_next]]

    this_end = tmp_df.loc[tmp_df.tracker_id == tracker_id].end_frame.values
    this_start = tmp_df.loc[tmp_df.tracker_id == tracker_id].start_frame.values

    result_df = pd.DataFrame(
        columns=["this_id", "nex_id", "this_start", "this_end", "nex_start", "nex_end"]
    )
    result_df.loc[len(result_df)] = [
        tracker_id,
        tmp_df_1.tracker_id.values,
        this_start,
        this_end,
        tmp_df_1.start_frame.values,
        tmp_df_1.end_frame.values,
    ]
    result_df["difference"] = np.abs(result_df.nex_end - result_df.this_start) - 1
    result_df["is_merge"] = np.any(result_df["difference"].values[0])
    return result_df


def split_tracker(tracker, frame):
    """
    Args:
        tracker: dict of tracker
        frame: int
    Returns:
        new_tracker: dict of tracker
    """
    new_tracker1 = {}
    new_tracker1["bboxes"] = tracker["bboxes"][: (frame - tracker["start_frame"] + 1)]
    new_tracker1["centroids"] = tracker["centroids"][
        : (frame - tracker["start_frame"] + 1)
    ]
    # new_tracker1['ovals'] = tracker['ovals'][:(frame - tracker['start_frame'] + 1)]
    new_tracker1["start_frame"] = tracker["start_frame"]
    new_tracker1["end_frame"] = frame
    new_tracker2 = {}
    new_tracker2["bboxes"] = tracker["bboxes"][(frame - tracker["start_frame"] + 1) :]
    new_tracker2["centroids"] = tracker["centroids"][
        (frame - tracker["start_frame"] + 1) :
    ]
    # new_tracker2["ovals"] = tracker["ovals"][(frame - tracker["start_frame"] + 1) :]
    new_tracker2["start_frame"] = frame + 1
    new_tracker2["end_frame"] = tracker["end_frame"]
    return new_tracker1, new_tracker2


def split_trackers(this_id, all_critical_split_df, all_trackers):
    sorted_df = all_critical_split_df.loc[
        all_critical_split_df.tracker_id == this_id
    ].sort_values("split_frame")
    this_tracker = all_trackers[this_id]

    tmp_str = []
    for i in range(len(sorted_df)):
        split_frame = sorted_df.iloc[i].split_frame - 1
        t1, t2 = split_tracker(this_tracker, split_frame)
        this_tracker = split_tracker(this_tracker, split_frame)[1]

        if i < len(sorted_df) - 1:
            tmp_str.append(t1)
        else:
            tmp_str.append(t1)
            tmp_str.append(t2)
    return tmp_str


def find_next(tracker_id, merge_summary_df):
    """
    Args:
        tracker_id: int
        merge_summary_df: dataframe
    Returns:
        next_id: int
    """
    tmp_df = merge_summary_df.loc[tracker_id]
    result_df = pd.DataFrame(columns=["this_id", "nex_id", "right_type"])
    if tmp_df.right_type == "disappear":
        result_df.loc[len(result_df)] = [
            tracker_id,
            conn_disappear_next(tmp_df, merge_summary_df),
            "disappear",
        ]
    else:
        for i in tmp_df.right_next[0]:
            result_df.loc[len(result_df)] = [tracker_id, i, tmp_df.right_type]
    return result_df


def find_all_nex(start_id, merge_summary_df, store_dict=[], banned_list=[]):
    find_next_df = find_next(start_id, merge_summary_df)
    store_dict.append(find_next_df)
    # print("${} find next: {}".format(start_num, find_next_df.nex_num.values))
    # print("$is in banned list: {}".format([i in banned_list for i in find_next_df.nex_num.values]))
    if np.all([i in banned_list for i in find_next_df.nex_id.values]):
        print("${} all path banned".format(find_next_df.nex_id.values))
        store_dict.append("all_path_banned")
        return "all_path_banned"
    if type(find_next_df.nex_id.values[0]) != str:
        rand_int = np.random.randint(0, len(find_next_df))
        while find_next_df.nex_id.values[rand_int] in banned_list:
            rand_int = np.random.randint(0, len(find_next_df))
        find_all_nex(
            find_next_df.nex_id.values[rand_int],
            merge_summary_df,
            store_dict,
            banned_list,
        )


def simple_find_nex(start_id, merge_df, banned_list):
    multi_index = merge_df.loc[
        (merge_df.right_type == "split") | (merge_df.left_type == "merge")
    ].index.values
    tmp_list = []
    find_all_nex(start_id, merge_df, tmp_list, banned_list)
    t_id = [i.this_id.values for i in tmp_list if type(i) != str]
    tmp_id = np.concatenate(t_id)
    indexes = np.unique(tmp_id, return_index=True)[1]
    worm = np.array([tmp_id[i] for i in sorted(indexes)])
    new_banned_list = worm[np.where([i not in multi_index for i in worm])[0]]
    new_banned_list = np.unique(np.concatenate([banned_list, new_banned_list]))
    if type(tmp_list[-1]) == str:
        worm = np.concatenate([worm, [-1]])

    return worm, new_banned_list


def find_prev(tracker_id, merge_summary_df):
    """
    Args:
        tracker_id: int
        merge_summary_df: dataframe
    Returns:
        next_num: int
    """
    tmp_df = merge_summary_df.loc[tracker_id]
    result_df = pd.DataFrame(columns=["this_id", "prev_id", "left_type"])
    if tmp_df.left_type == "appear":
        result_df.loc[len(result_df)] = [
            tracker_id,
            conn_disappear_prev(tmp_df, merge_summary_df),
            "appear",
        ]
    else:
        for i in tmp_df.left_prev[0]:
            result_df.loc[len(result_df)] = [tracker_id, i, tmp_df.left_type]
    return result_df


def find_all_prev(start_id, merge_summary_df, store_dict=[], banned_list=[]):
    find_prev_df = find_prev(start_id, merge_summary_df)
    store_dict.insert(0, find_prev_df)
    # print("${} find next: {}".format(start_num, find_next_df.nex_num.values))
    # print("$is in banned list: {}".format([i in banned_list for i in find_next_df.nex_num.values]))
    if np.all([i in banned_list for i in find_prev_df.prev_id.values]):
        print("${} all path banned".format(find_prev_df.prev_id.values))
        store_dict.insert(0, "all_path_banned")
        return "all_path_banned"
    if type(find_prev_df.prev_id.values[0]) != str:
        rand_int = np.random.randint(0, len(find_prev_df))
        while find_prev_df.prev_id.values[rand_int] in banned_list:
            rand_int = np.random.randint(0, len(find_prev_df))
        find_all_prev(
            find_prev_df.prev_id.values[rand_int],
            merge_summary_df,
            store_dict,
            banned_list,
        )


def simple_find_prev(start_id, merge_df, banned_list):
    multi_index = merge_df.loc[
        (merge_df.right_type == "split") | (merge_df.left_type == "merge")
    ].index.values
    tmp_list = []
    find_all_prev(start_id, merge_df, tmp_list, banned_list)
    t_id = [i.this_id.values for i in tmp_list if type(i) != str]
    tmp_id = np.concatenate(t_id)
    indexes = np.unique(tmp_id, return_index=True)[1]
    worm = np.array([tmp_id[i] for i in sorted(indexes)])
    new_banned_list = worm[np.where([i not in multi_index for i in worm])[0]]
    new_banned_list = np.unique(np.concatenate([banned_list, new_banned_list]))
    if type(tmp_list[0]) == str:
        worm = np.concatenate([[-1], worm])

    return worm, new_banned_list
